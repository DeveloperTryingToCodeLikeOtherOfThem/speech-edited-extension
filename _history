{"entries":[{"timestamp":1756957373911,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":5149,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":221,"length1":45,"diffs":[[1,"    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1756957973648,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3423,"length1":59,"diffs":[[1,"                        \r\n"]]},{"start1":4774,"length1":64,"diffs":[[1,"            if (!_currentCutscene().soundEnabled) return;\r\n"]]},{"start1":4877,"length1":79,"diffs":[[1,""]]},{"start1":4879,"length1":1082,"diffs":[[1,"        \r\n"]]},{"start1":4901,"length1":67,"diffs":[[1,""]]},{"start1":5149,"length1":92,"diffs":[[1,""]]}]}]},{"timestamp":1756958532801,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":88,"length1":28,"diffs":[[1,"    export class Speech {\r\n"]]}]}]},{"timestamp":1756994811350,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":88,"length1":27,"diffs":[[1,"    export class eSpeech {\r\n"]]}]}]},{"timestamp":1756994872256,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":68,"diffs":[[1,""]]},{"start1":20,"length1":83,"diffs":[[1,""]]},{"start1":489,"length1":69,"diffs":[[1,"        constructor(intervalMs: number = 150) {\r\n"]]},{"start1":3423,"length1":60,"diffs":[[1,"                    this.playWithVolume(defaultTick, 100)\r\n"]]},{"start1":6176,"length1":43,"diffs":[[1,"const printText = new speech.Speech(150);\r\n"]]}]}]},{"timestamp":1756995471180,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":88,"length1":86,"diffs":[[1,"     export enum SpeechSpeed {\r\n      Slow,\r\n      Normal, \r\n      Fast\r\n"]]},{"start1":171,"length1":102,"diffs":[[1,""]]},{"start1":640,"length1":57,"diffs":[[1,"        constructor(intervalMs: SpeechSpeed = SpeechSpeed.Normal) {\r\n"]]},{"start1":1980,"length1":104,"diffs":[[1,"        public printDialog(message: string) {\r\n            this.update(message);\r\n"]]},{"start1":2120,"length1":60,"diffs":[[1,"        protected update(message: string) {\r\n"]]},{"start1":3594,"length1":61,"diffs":[[1,"                    this.playWithVolume(defaultTick, Mess)\r\n"]]},{"start1":6296,"length1":18,"diffs":[[1,"    return isMenuOpen();\r\n"]]},{"start1":6327,"length1":0,"diffs":[[1,"\r\n"]]},{"start1":6348,"length1":265,"diffs":[[1,"const printText = new speech.Speech(100);\r\nprintText.printDialog(\"Hello world! This prints like a typewriter and wraps words properly. It scrolls if the text exceeds the bubble height, and plays a nice tick sound per letter.\");\r\n"]]},{"start1":6669,"length1":3,"diffs":[[1,""]]}]}]},{"timestamp":1756996068044,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":6479,"length1":40,"diffs":[[1,"const printText = new speech.Speech(speech.Speed.Normal);\r\n"]]}]}]},{"timestamp":1757301015731,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":189,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1756957373910,"editorVersion":"2.0.56","text":{"main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"speech edited\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1756994811350,"editorVersion":"2.0.56","text":{"main.ts":"namespace speech {\r\n    const defaultTick = new music.Melody(\"@20,10,0,0 c5:1-150\");\r\n\r\n    export class Speech {\r\n        private bubble: Image;\r\n        private sprite: Sprite;\r\n        private message: string;\r\n        private currentIndex: number;\r\n        private interval: number;\r\n        private maxCharsPerLine: number;\r\n        private maxLines: number;\r\n        private intervalHandle: number;\r\n        public soundEnabled: boolean;\r\n        private tickSound: music.Melody;\r\n\r\n        constructor(intervalMs: number = 150) {\r\n            this.bubble = image.create(160, 60);\r\n            this.bubble.fill(0);\r\n            this.sprite = sprites.create(this.bubble);\r\n            this.message = \"\";\r\n            this.currentIndex = 0;\r\n            this.interval = intervalMs;\r\n            this.maxCharsPerLine = 26;\r\n            this.maxLines = 3;\r\n            this.intervalHandle = 0;\r\n            this.soundEnabled = true;\r\n            this.tickSound = defaultTick;\r\n        }\r\n\r\n        private wrapText(message: string): string[] {\r\n            const words = message.split(\" \");\r\n            const lines: string[] = [];\r\n            let currentLine = \"\";\r\n\r\n            for (let w of words) {\r\n                if ((currentLine + (currentLine ? \" \" : \"\") + w).length > this.maxCharsPerLine) {\r\n                    lines.push(currentLine);\r\n                    currentLine = w;\r\n                } else {\r\n                    currentLine += (currentLine ? \" \" : \"\") + w;\r\n                }\r\n            }\r\n            if (currentLine) lines.push(currentLine);\r\n            return lines;\r\n        }\r\n\r\n        private stopInterval() {\r\n            if (this.intervalHandle) {\r\n                clearInterval(this.intervalHandle);\r\n                this.intervalHandle = 0;\r\n            }\r\n        }\r\n\r\n        public printDialog(message: string) {\r\n            this.update(message);\r\n        }\r\n\r\n        private running: boolean = false;\r\n\r\n        protected update(message: string) {\r\n            this.running = true;\r\n            this.currentIndex = 0;\r\n            this.message = message;\r\n\r\n            game.onUpdateInterval(this.interval, () => {\r\n                if (!this.running) return;\r\n\r\n                if (this.currentIndex < this.message.length) {\r\n                    // 1️⃣ Slice message up to currentIndex for typewriter effect\r\n                    const partial = this.message.slice(0, this.currentIndex + 1);\r\n\r\n                    // 2️⃣ Wrap words into lines\r\n                    const lines = this.wrapText(partial);\r\n\r\n                    // 3️⃣ Only keep last maxLines for scrolling effect\r\n                    const visibleLines = lines.length > this.maxLines ? lines.slice(lines.length - this.maxLines) : lines;\r\n\r\n                    // 4️⃣ Clear and redraw bubble background\r\n                    this.bubble.fill(0);                      // clear bubble\r\n                    this.bubble.fillRect(0, 0, 160, 60, 1);  // background color\r\n\r\n                    // 5️⃣ Draw each visible line\r\n                    for (let i = 0; i < visibleLines.length; i++) {\r\n                        this.bubble.print(visibleLines[i], 4, 4 + i * 16, 15); // letter color\r\n                    }\r\n\r\n                    // 6️⃣ Update sprite image\r\n                    this.sprite.setImage(this.bubble);\r\n\r\n                    // 7️⃣ Play tick sound per letter\r\n                    if (this.soundEnabled) {\r\n                    this.playWithVolume(defaultTick, 100)\r\n                    }\r\n\r\n                    // 8️⃣ Move to next letter\r\n                    this.currentIndex++;\r\n                } else {\r\n                    // 9️⃣ Stop updating when finished\r\n                    this.running = false;\r\n                }\r\n\r\n                if(!this.running) {\r\n                    this.clearBubble()\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        clearBubble() {\r\n            this.bubble.fill(0)\r\n        }\r\n \r\n        // optional: change bubble color\r\n        public setBubbleColor(color: number) {\r\n            this.bubble.fillRect(0, 0, 160, 60, color);\r\n        }\r\n\r\n        // optional: change letter color dynamically\r\n        public setLetterColor(color: number) {\r\n            const partial = this.message.slice(0, this.currentIndex);\r\n            const lines = this.wrapText(partial);\r\n            const visibleLines = lines.length > this.maxLines ? lines.slice(lines.length - this.maxLines) : lines;\r\n\r\n            this.bubble.fill(0);\r\n            this.bubble.fillRect(0, 0, 160, 60, 1);\r\n            for (let i = 0; i < visibleLines.length; i++) {\r\n                this.bubble.print(visibleLines[i], 4, 4 + i * 16, color);\r\n            }\r\n            this.sprite.setImage(this.bubble);\r\n        }\r\n\r\n        playWithVolume(sound: music.Melody, volume: number) {\r\n            if (!this._currentCutscene().soundEnabled) return;\r\n            sound.play(volume);\r\n        }\r\n        \r\n        _currentCutscene() {\r\n            let stateStack: Speech[];\r\n\r\n            if (!stateStack) {\r\n                stateStack = [];\r\n\r\n                game.addScenePushHandler(() => {\r\n                    stateStack.push(new Speech());\r\n                });\r\n\r\n                game.addScenePopHandler(() => {\r\n                    if (stateStack.length) {\r\n                        stateStack[stateStack.length - 1].cancel();\r\n                        stateStack.pop();\r\n                    }\r\n                });\r\n            }\r\n            if (!stateStack.length) {\r\n                stateStack.push(new Speech());\r\n            }\r\n            return stateStack[stateStack.length - 1];\r\n        }\r\n       \r\n        currentTask: Task\r\n\r\n        cancel() {\r\n            // if (isMenuOpen()) {\r\n            //     closeMenu();\r\n            // }\r\n            // if (this.currentTask && this.currentTask.cancel) {\r\n            //     this.currentTask.cancel();\r\n            //     this.currentTask = null;\r\n            // }\r\n            // if (this.state === State.Running) {\r\n            //     this.state = State.Cancelled;\r\n            // }\r\n        }\r\n\r\n    }\r\n}\r\n\r\nfunction isMenuOpen(): boolean {\r\n    return isMenuOpen();\r\n}\r\n\r\n\r\n// Example usage:\r\nconst printText = new speech.Speech(150);\r\nprintText.printDialog(\"Hello world! This prints like a typewriter and wraps words properly. It scrolls if the text exceeds the bubble height, and plays a nice tick sound per letter.\");\r\n\r\ninterface Task {\r\n    isDone(): boolean;\r\n    key?: string;\r\n    cancel?: () => void;\r\n}\r\n","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"speech edited\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1757210292972,"editorVersion":"2.0.56","text":{"main.ts":"// adapted from https://github.com/riknoll/arcade-story/message.ts\r\nnamespace speech {\r\n     export enum Volume {\r\n      Quiet = 20,\r\n      Normal = 100, \r\n      Loud = 200\r\n     }\r\n\r\n     export enum Speed {\r\n         Slow = 200,\r\n         Normal = 100,\r\n         Fast = 50\r\n     }\r\n\r\n    const defaultTick = new music.Melody(\"@20,10,0,0 c5:1-150\");\r\n\r\n    export class Speech {\r\n        private bubble: Image;\r\n        private sprite: Sprite;\r\n        private message: string;\r\n        private currentIndex: number;\r\n        private interval: number;\r\n        private maxCharsPerLine: number;\r\n        private maxLines: number;\r\n        private intervalHandle: number;\r\n        public soundEnabled: boolean;\r\n        private tickSound: music.Melody;\r\n\r\n        constructor(intervalMs: Speed = Speed.Normal) {\r\n            this.bubble = image.create(160, 60);\r\n            this.bubble.fill(0);\r\n            this.sprite = sprites.create(this.bubble);\r\n            this.message = \"\";\r\n            this.currentIndex = 0;\r\n            this.interval = intervalMs;\r\n            this.maxCharsPerLine = 26;\r\n            this.maxLines = 3;\r\n            this.intervalHandle = 0;\r\n            this.soundEnabled = true;\r\n            this.tickSound = defaultTick;\r\n        }\r\n\r\n        private wrapText(message: string): string[] {\r\n            const words = message.split(\" \");\r\n            const lines: string[] = [];\r\n            let currentLine = \"\";\r\n\r\n            for (let w of words) {\r\n                if ((currentLine + (currentLine ? \" \" : \"\") + w).length > this.maxCharsPerLine) {\r\n                    lines.push(currentLine);\r\n                    currentLine = w;\r\n                } else {\r\n                    currentLine += (currentLine ? \" \" : \"\") + w;\r\n                }\r\n            }\r\n            if (currentLine) lines.push(currentLine);\r\n            return lines;\r\n        }\r\n\r\n        private stopInterval() {\r\n            if (this.intervalHandle) {\r\n                clearInterval(this.intervalHandle);\r\n                this.intervalHandle = 0;\r\n            }\r\n        }\r\n\r\n        public printDialog(message: string, speed: Volume) {\r\n            this.update(message, speed);\r\n        }\r\n\r\n        private running: boolean = false;\r\n\r\n        protected update(message: string, speed: Volume) {\r\n            this.running = true;\r\n            this.currentIndex = 0;\r\n            this.message = message;\r\n\r\n            game.onUpdateInterval(this.interval, () => {\r\n                if (!this.running) return;\r\n\r\n                if (this.currentIndex < this.message.length) {\r\n                    // 1️⃣ Slice message up to currentIndex for typewriter effect\r\n                    const partial = this.message.slice(0, this.currentIndex + 1);\r\n\r\n                    // 2️⃣ Wrap words into lines\r\n                    const lines = this.wrapText(partial);\r\n\r\n                    // 3️⃣ Only keep last maxLines for scrolling effect\r\n                    const visibleLines = lines.length > this.maxLines ? lines.slice(lines.length - this.maxLines) : lines;\r\n\r\n                    // 4️⃣ Clear and redraw bubble background\r\n                    this.bubble.fill(0);                      // clear bubble\r\n                    this.bubble.fillRect(0, 0, 160, 60, 1);  // background color\r\n\r\n                    // 5️⃣ Draw each visible line\r\n                    for (let i = 0; i < visibleLines.length; i++) {\r\n                        this.bubble.print(visibleLines[i], 4, 4 + i * 16, 15); // letter color\r\n                    }\r\n\r\n                    // 6️⃣ Update sprite image\r\n                    this.sprite.setImage(this.bubble);\r\n\r\n                    // 7️⃣ Play tick sound per letter\r\n                    if (this.soundEnabled) {\r\n                    this.playWithVolume(defaultTick, speed)\r\n                    }\r\n\r\n                    // 8️⃣ Move to next letter\r\n                    this.currentIndex++;\r\n                } else {\r\n                    // 9️⃣ Stop updating when finished\r\n                    this.running = false;\r\n                }\r\n\r\n                if(!this.running) {\r\n                    this.clearBubble()\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        clearBubble() {\r\n            this.bubble.fill(0)\r\n        }\r\n \r\n        // optional: change bubble color\r\n        public setBubbleColor(color: number) {\r\n            this.bubble.fillRect(0, 0, 160, 60, color);\r\n        }\r\n\r\n        // optional: change letter color dynamically\r\n        public setLetterColor(color: number) {\r\n            const partial = this.message.slice(0, this.currentIndex);\r\n            const lines = this.wrapText(partial);\r\n            const visibleLines = lines.length > this.maxLines ? lines.slice(lines.length - this.maxLines) : lines;\r\n\r\n            this.bubble.fill(0);\r\n            this.bubble.fillRect(0, 0, 160, 60, 1);\r\n            for (let i = 0; i < visibleLines.length; i++) {\r\n                this.bubble.print(visibleLines[i], 4, 4 + i * 16, color);\r\n            }\r\n            this.sprite.setImage(this.bubble);\r\n        }\r\n\r\n        playWithVolume(sound: music.Melody, volume: number) {\r\n            if (!this._currentCutscene().soundEnabled) return;\r\n            sound.play(volume);\r\n        }\r\n        \r\n        _currentCutscene() {\r\n            let stateStack: Speech[];\r\n\r\n            if (!stateStack) {\r\n                stateStack = [];\r\n\r\n                game.addScenePushHandler(() => {\r\n                    stateStack.push(new Speech());\r\n                });\r\n\r\n                game.addScenePopHandler(() => {\r\n                    if (stateStack.length) {\r\n                        stateStack[stateStack.length - 1].cancel();\r\n                        stateStack.pop();\r\n                    }\r\n                });\r\n            }\r\n            if (!stateStack.length) {\r\n                stateStack.push(new Speech());\r\n            }\r\n            return stateStack[stateStack.length - 1];\r\n        }\r\n       \r\n        currentTask: Task\r\n\r\n        cancel() {\r\n            // if (isMenuOpen()) {\r\n            //     closeMenu();\r\n            // }\r\n            // if (this.currentTask && this.currentTask.cancel) {\r\n            //     this.currentTask.cancel();\r\n            //     this.currentTask = null;\r\n            // }\r\n            // if (this.state === State.Running) {\r\n            //     this.state = State.Cancelled;\r\n            // }\r\n        }\r\n\r\n    }\r\n}\r\n\r\nfunction isMenuOpen(): boolean {\r\n    return false\r\n}\r\n\r\n// Example usage:\r\nconst printText = new speech.Speech();\r\nprintText.printDialog(\"Hello world! This prints like a typewriter and wraps words properly. It scrolls if the text exceeds the bubble height, and plays a nice tick sound per letter.\", speech.Volume.Loud);\r\n\r\ninterface Task {\r\n    isDone(): boolean;\r\n    key?: string;\r\n    cancel?: () => void;\r\n}\r\n\r\n ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"speech edited\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1757301015731,"editorVersion":"2.0.56","text":{"main.ts":"// adapted from https://github.com/riknoll/arcade-story/message.ts\r\nnamespace speech {\r\n     export enum Volume {\r\n      Quiet = 20,\r\n      Normal = 100, \r\n      Loud = 200\r\n     }\r\n\r\n     export enum Speed {\r\n         Slow = 200,\r\n         Normal = 100,\r\n         Fast = 50\r\n     }\r\n\r\n    const defaultTick = new music.Melody(\"@20,10,0,0 c5:1-150\");\r\n\r\n    export class Speech {\r\n        private bubble: Image;\r\n        private sprite: Sprite;\r\n        private message: string;\r\n        private currentIndex: number;\r\n        private interval: number;\r\n        private maxCharsPerLine: number;\r\n        private maxLines: number;\r\n        private intervalHandle: number;\r\n        public soundEnabled: boolean;\r\n        private tickSound: music.Melody;\r\n\r\n        constructor(intervalMs: Speed = Speed.Normal) {\r\n            this.bubble = image.create(160, 60);\r\n            this.bubble.fill(0);\r\n            this.sprite = sprites.create(this.bubble);\r\n            this.message = \"\";\r\n            this.currentIndex = 0;\r\n            this.interval = intervalMs;\r\n            this.maxCharsPerLine = 26;\r\n            this.maxLines = 3;\r\n            this.intervalHandle = 0;\r\n            this.soundEnabled = true;\r\n            this.tickSound = defaultTick;\r\n        }\r\n\r\n        private wrapText(message: string): string[] {\r\n            const words = message.split(\" \");\r\n            const lines: string[] = [];\r\n            let currentLine = \"\";\r\n\r\n            for (let w of words) {\r\n                if ((currentLine + (currentLine ? \" \" : \"\") + w).length > this.maxCharsPerLine) {\r\n                    lines.push(currentLine);\r\n                    currentLine = w;\r\n                } else {\r\n                    currentLine += (currentLine ? \" \" : \"\") + w;\r\n                }\r\n            }\r\n            if (currentLine) lines.push(currentLine);\r\n            return lines;\r\n        }\r\n\r\n        private stopInterval() {\r\n            if (this.intervalHandle) {\r\n                clearInterval(this.intervalHandle);\r\n                this.intervalHandle = 0;\r\n            }\r\n        }\r\n\r\n        public printDialog(message: string, speed: Volume) {\r\n            this.update(message, speed);\r\n        }\r\n\r\n        private running: boolean = false;\r\n\r\n        protected update(message: string, speed: Volume) {\r\n            this.running = true;\r\n            this.currentIndex = 0;\r\n            this.message = message;\r\n\r\n            game.onUpdateInterval(this.interval, () => {\r\n                if (!this.running) return;\r\n\r\n                if (this.currentIndex < this.message.length) {\r\n                    // 1️⃣ Slice message up to currentIndex for typewriter effect\r\n                    const partial = this.message.slice(0, this.currentIndex + 1);\r\n\r\n                    // 2️⃣ Wrap words into lines\r\n                    const lines = this.wrapText(partial);\r\n\r\n                    // 3️⃣ Only keep last maxLines for scrolling effect\r\n                    const visibleLines = lines.length > this.maxLines ? lines.slice(lines.length - this.maxLines) : lines;\r\n\r\n                    // 4️⃣ Clear and redraw bubble background\r\n                    this.bubble.fill(0);                      // clear bubble\r\n                    this.bubble.fillRect(0, 0, 160, 60, 1);  // background color\r\n\r\n                    // 5️⃣ Draw each visible line\r\n                    for (let i = 0; i < visibleLines.length; i++) {\r\n                        this.bubble.print(visibleLines[i], 4, 4 + i * 16, 15); // letter color\r\n                    }\r\n\r\n                    // 6️⃣ Update sprite image\r\n                    this.sprite.setImage(this.bubble);\r\n\r\n                    // 7️⃣ Play tick sound per letter\r\n                    if (this.soundEnabled) {\r\n                    this.playWithVolume(defaultTick, speed)\r\n                    }\r\n\r\n                    // 8️⃣ Move to next letter\r\n                    this.currentIndex++;\r\n                } else {\r\n                    // 9️⃣ Stop updating when finished\r\n                    this.running = false;\r\n                }\r\n\r\n                if(!this.running) {\r\n                    this.clearBubble()\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        clearBubble() {\r\n            this.bubble.fill(0)\r\n        }\r\n \r\n        // optional: change bubble color\r\n        public setBubbleColor(color: number) {\r\n            this.bubble.fillRect(0, 0, 160, 60, color);\r\n        }\r\n\r\n        // optional: change letter color dynamically\r\n        public setLetterColor(color: number) {\r\n            const partial = this.message.slice(0, this.currentIndex);\r\n            const lines = this.wrapText(partial);\r\n            const visibleLines = lines.length > this.maxLines ? lines.slice(lines.length - this.maxLines) : lines;\r\n\r\n            this.bubble.fill(0);\r\n            this.bubble.fillRect(0, 0, 160, 60, 1);\r\n            for (let i = 0; i < visibleLines.length; i++) {\r\n                this.bubble.print(visibleLines[i], 4, 4 + i * 16, color);\r\n            }\r\n            this.sprite.setImage(this.bubble);\r\n        }\r\n\r\n        playWithVolume(sound: music.Melody, volume: number) {\r\n            if (!this._currentCutscene().soundEnabled) return;\r\n            sound.play(volume);\r\n        }\r\n        \r\n        _currentCutscene() {\r\n            let stateStack: Speech[];\r\n\r\n            if (!stateStack) {\r\n                stateStack = [];\r\n\r\n                game.addScenePushHandler(() => {\r\n                    stateStack.push(new Speech());\r\n                });\r\n\r\n                game.addScenePopHandler(() => {\r\n                    if (stateStack.length) {\r\n                        stateStack[stateStack.length - 1].cancel();\r\n                        stateStack.pop();\r\n                    }\r\n                });\r\n            }\r\n            if (!stateStack.length) {\r\n                stateStack.push(new Speech());\r\n            }\r\n            return stateStack[stateStack.length - 1];\r\n        }\r\n       \r\n        currentTask: Task\r\n\r\n        cancel() {\r\n            // if (isMenuOpen()) {\r\n            //     closeMenu();\r\n            // }\r\n            // if (this.currentTask && this.currentTask.cancel) {\r\n            //     this.currentTask.cancel();\r\n            //     this.currentTask = null;\r\n            // }\r\n            // if (this.state === State.Running) {\r\n            //     this.state = State.Cancelled;\r\n            // }\r\n        }\r\n\r\n    }\r\n}\r\n\r\nfunction isMenuOpen(): boolean {\r\n    return false\r\n}\r\n\r\n// Example usage:\r\nconst printText = new speech.Speech();\r\nprintText.printDialog(\"Hello world! This prints like a typewriter and wraps words properly. It scrolls if the text exceeds the bubble height, and plays a nice tick sound per letter.\", speech.Volume.Loud);\r\n\r\ninterface Task {\r\n    isDone(): boolean;\r\n    key?: string;\r\n    cancel?: () => void;\r\n}\r\n\r\n ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"speech edited\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}}],"shares":[],"lastSaveTime":1757301015752}